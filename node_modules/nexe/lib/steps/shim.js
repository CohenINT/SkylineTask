"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
function default_1(compiler, next) {
    compiler.shims.push(util_1.wrap("process.__nexe = " + JSON.stringify(compiler.binaryConfiguration) + ";\n" +
        "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar originalFsMethods = null;\r\nvar lazyRestoreFs = function () { };\r\nfunction shimFs(binary, fs) {\r\n    if (fs === void 0) { fs = require('fs'); }\r\n    if (originalFsMethods !== null) {\r\n        return;\r\n    }\r\n    originalFsMethods = Object.assign({}, fs);\r\n    var blobPath = binary.blobPath, manifest = binary.resources, _a = binary.layout, resourceStart = _a.resourceStart, stat = _a.stat, directories = {}, notAFile = '!@#$%^&*', isWin = process.platform.startsWith('win'), isString = function (x) { return typeof x === 'string' || x instanceof String; }, noop = function () { }, path = require('path'), baseDir = path.dirname(process.execPath);\r\n    var log = function (_) { return true; };\r\n    if ((process.env.DEBUG || '').toLowerCase().includes('nexe:require')) {\r\n        log = function (text) { return process.stderr.write('[nexe] - ' + text + '\\n'); };\r\n    }\r\n    var getKey = function getKey(filepath) {\r\n        if (Buffer.isBuffer(filepath)) {\r\n            filepath = filepath.toString();\r\n        }\r\n        if (!isString(filepath)) {\r\n            return notAFile;\r\n        }\r\n        var key = path.resolve(baseDir, filepath);\r\n        if (isWin && key.substr(1, 2) === ':\\\\') {\r\n            key = key[0].toUpperCase() + key.substr(1);\r\n        }\r\n        return key;\r\n    };\r\n    var statTime = function () {\r\n        return {\r\n            dev: 0,\r\n            ino: 0,\r\n            nlink: 0,\r\n            rdev: 0,\r\n            uid: 123,\r\n            gid: 500,\r\n            blksize: 4096,\r\n            blocks: 0,\r\n            atime: new Date(stat.atime),\r\n            atimeMs: stat.atime.getTime(),\r\n            mtime: new Date(stat.mtime),\r\n            mtimeMs: stat.mtime.getTime(),\r\n            ctime: new Date(stat.ctime),\r\n            ctimMs: stat.ctime.getTime(),\r\n            birthtime: new Date(stat.birthtime),\r\n            birthtimeMs: stat.birthtime.getTime()\r\n        };\r\n    };\r\n    var createStat = function (extensions) {\r\n        return Object.assign(new fs.Stats(), binary.layout.stat, statTime(), extensions);\r\n    };\r\n    var ownStat = function (filepath) {\r\n        setupManifest();\r\n        var key = getKey(filepath);\r\n        if (directories[key]) {\r\n            var mode = binary.layout.stat.mode;\r\n            mode |= fs.constants.S_IFDIR;\r\n            mode &= ~fs.constants.S_IFREG;\r\n            return createStat({ mode: mode, size: 0 });\r\n        }\r\n        if (manifest[key]) {\r\n            return createStat({ size: manifest[key][1] });\r\n        }\r\n    };\r\n    function makeLong(filepath) {\r\n        return path._makeLong && path._makeLong(filepath);\r\n    }\r\n    function fileOpts(options) {\r\n        return !options ? {} : isString(options) ? { encoding: options } : options;\r\n    }\r\n    var setupManifest = function () {\r\n        Object.keys(manifest).forEach(function (filepath) {\r\n            var entry = manifest[filepath];\r\n            var absolutePath = getKey(filepath);\r\n            var longPath = makeLong(absolutePath);\r\n            var normalizedPath = path.normalize(filepath);\r\n            if (!manifest[absolutePath]) {\r\n                manifest[absolutePath] = entry;\r\n            }\r\n            if (longPath && !manifest[longPath]) {\r\n                manifest[longPath] = entry;\r\n            }\r\n            if (!manifest[normalizedPath]) {\r\n                manifest[normalizedPath] = manifest[filepath];\r\n            }\r\n            var currentDir = path.dirname(absolutePath);\r\n            var prevDir = absolutePath;\r\n            while (currentDir !== prevDir) {\r\n                directories[currentDir] = directories[currentDir] || {};\r\n                directories[currentDir][path.basename(prevDir)] = true;\r\n                var longDir = makeLong(currentDir);\r\n                if (longDir && !directories[longDir]) {\r\n                    directories[longDir] = directories[currentDir];\r\n                }\r\n                prevDir = currentDir;\r\n                currentDir = path.dirname(currentDir);\r\n            }\r\n        });\r\n        manifest[notAFile] = false;\r\n        directories[notAFile] = false;\r\n        setupManifest = noop;\r\n    };\r\n    //naive patches intended to work for most use cases\r\n    var nfs = {\r\n        existsSync: function existsSync(filepath) {\r\n            setupManifest();\r\n            var key = getKey(filepath);\r\n            if (manifest[key] || directories[key]) {\r\n                return true;\r\n            }\r\n            return originalFsMethods.existsSync.apply(fs, arguments);\r\n        },\r\n        realpath: function realpath(filepath, options, cb) {\r\n            setupManifest();\r\n            var key = getKey(filepath);\r\n            if (isString(filepath) && (manifest[filepath] || manifest[key])) {\r\n                return process.nextTick(function () { return cb(null, filepath); });\r\n            }\r\n            return originalFsMethods.realpath.call(fs, filepath, options, cb);\r\n        },\r\n        realpathSync: function realpathSync(filepath, options) {\r\n            setupManifest();\r\n            var key = getKey(filepath);\r\n            if (manifest[key]) {\r\n                return filepath;\r\n            }\r\n            return originalFsMethods.realpathSync.call(fs, filepath, options);\r\n        },\r\n        readdir: function readdir(filepath, options, callback) {\r\n            setupManifest();\r\n            var dir = directories[getKey(filepath)];\r\n            if (dir) {\r\n                if ('function' === typeof options) {\r\n                    callback = options;\r\n                    options = { encoding: 'utf8' };\r\n                }\r\n                process.nextTick(function () { return callback(null, Object.keys(dir)); });\r\n            }\r\n            else {\r\n                return originalFsMethods.readdir.apply(fs, arguments);\r\n            }\r\n        },\r\n        readdirSync: function readdirSync(filepath, options) {\r\n            setupManifest();\r\n            var dir = directories[getKey(filepath)];\r\n            if (dir) {\r\n                return Object.keys(dir);\r\n            }\r\n            return originalFsMethods.readdirSync.apply(fs, arguments);\r\n        },\r\n        readFile: function readFile(filepath, options, callback) {\r\n            setupManifest();\r\n            var entry = manifest[getKey(filepath)];\r\n            if (!entry) {\r\n                return originalFsMethods.readFile.apply(fs, arguments);\r\n            }\r\n            var offset = entry[0], length = entry[1];\r\n            var resourceOffset = resourceStart + offset;\r\n            var encoding = fileOpts(options).encoding;\r\n            callback = typeof options === 'function' ? options : callback;\r\n            fs.open(blobPath, 'r', function (err, fd) {\r\n                if (err)\r\n                    return callback(err, null);\r\n                fs.read(fd, Buffer.alloc(length), 0, length, resourceOffset, function (error, bytesRead, result) {\r\n                    if (error) {\r\n                        return fs.close(fd, function () {\r\n                            callback(error, null);\r\n                        });\r\n                    }\r\n                    fs.close(fd, function (err) {\r\n                        if (err) {\r\n                            return callback(err, result);\r\n                        }\r\n                        callback(err, encoding ? result.toString(encoding) : result);\r\n                    });\r\n                });\r\n            });\r\n        },\r\n        createReadStream: function createReadStream(filepath, options) {\r\n            setupManifest();\r\n            var entry = manifest[getKey(filepath)];\r\n            if (!entry) {\r\n                return originalFsMethods.createReadStream.apply(fs, arguments);\r\n            }\r\n            var offset = entry[0], length = entry[1];\r\n            var resourceOffset = resourceStart + offset;\r\n            var opts = fileOpts(options);\r\n            return fs.createReadStream(blobPath, Object.assign({}, opts, {\r\n                start: resourceOffset,\r\n                end: resourceOffset + length - 1\r\n            }));\r\n        },\r\n        readFileSync: function readFileSync(filepath, options) {\r\n            setupManifest();\r\n            var entry = manifest[getKey(filepath)];\r\n            if (!entry) {\r\n                return originalFsMethods.readFileSync.apply(fs, arguments);\r\n            }\r\n            var offset = entry[0], length = entry[1];\r\n            var resourceOffset = resourceStart + offset;\r\n            var encoding = fileOpts(options).encoding;\r\n            var fd = fs.openSync(process.execPath, 'r');\r\n            var result = Buffer.alloc(length);\r\n            fs.readSync(fd, result, 0, length, resourceOffset);\r\n            fs.closeSync(fd);\r\n            return encoding ? result.toString(encoding) : result;\r\n        },\r\n        statSync: function statSync(filepath) {\r\n            var stat = ownStat(filepath);\r\n            if (stat) {\r\n                return stat;\r\n            }\r\n            return originalFsMethods.statSync.apply(fs, arguments);\r\n        },\r\n        stat: function stat(filepath, callback) {\r\n            var stat = ownStat(filepath);\r\n            if (stat) {\r\n                process.nextTick(function () {\r\n                    callback(null, stat);\r\n                });\r\n            }\r\n            else {\r\n                return originalFsMethods.stat.apply(fs, arguments);\r\n            }\r\n        }\r\n    };\r\n    if (typeof fs.exists === 'function') {\r\n        nfs.exists = function (filepath, cb) {\r\n            cb = cb || noop;\r\n            var exists = nfs.existsSync(filepath);\r\n            process.nextTick(function () { return cb(exists); });\r\n        };\r\n    }\r\n    var patches = process.nexe.patches || {};\r\n    delete process.nexe;\r\n    patches.internalModuleReadFile = function (original) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var filepath = args[0];\r\n        setupManifest();\r\n        if (manifest[filepath]) {\r\n            log('read     (hit)              ' + filepath);\r\n            return nfs.readFileSync(filepath, 'utf-8');\r\n        }\r\n        log('read          (miss)       ' + filepath);\r\n        return original.call.apply(original, [this].concat(args));\r\n    };\r\n    patches.internalModuleReadJSON = patches.internalModuleReadFile;\r\n    patches.internalModuleStat = function (original) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        setupManifest();\r\n        var filepath = args[0];\r\n        if (manifest[filepath]) {\r\n            log('stat     (hit)              ' + filepath + '   ' + 0);\r\n            return 0;\r\n        }\r\n        if (directories[filepath]) {\r\n            log('stat dir (hit)              ' + filepath + '   ' + 1);\r\n            return 1;\r\n        }\r\n        var res = original.call.apply(original, [this].concat(args));\r\n        if (res === 0) {\r\n            log('stat          (miss)        ' + filepath + '   ' + res);\r\n        }\r\n        else if (res === 1) {\r\n            log('stat dir      (miss)        ' + filepath + '   ' + res);\r\n        }\r\n        else {\r\n            log('stat                 (fail) ' + filepath + '   ' + res);\r\n        }\r\n        return res;\r\n    };\r\n    if (typeof fs.exists === 'function') {\r\n        nfs.exists = function (filepath, cb) {\r\n            cb = cb || noop;\r\n            var exists = nfs.existsSync(filepath);\r\n            if (!exists) {\r\n                return originalFsMethods.exists(filepath, cb);\r\n            }\r\n            process.nextTick(function () { return cb(exists); });\r\n        };\r\n    }\r\n    if (typeof fs.copyFile === 'function') {\r\n        nfs.copyFile = function (filepath, dest, flags, callback) {\r\n            setupManifest();\r\n            var entry = manifest[getKey(filepath)];\r\n            if (!entry) {\r\n                return originalFsMethods.copyFile.apply(fs, arguments);\r\n            }\r\n            if (typeof flags === 'function') {\r\n                callback = flags;\r\n                flags = 0;\r\n            }\r\n            nfs.readFile(filepath, function (err, buffer) {\r\n                if (err) {\r\n                    return callback(err);\r\n                }\r\n                originalFsMethods.writeFile(dest, buffer, function (err) {\r\n                    if (err) {\r\n                        return callback(err);\r\n                    }\r\n                    callback(null);\r\n                });\r\n            });\r\n        };\r\n        nfs.copyFileSync = function (filepath, dest) {\r\n            setupManifest();\r\n            var entry = manifest[getKey(filepath)];\r\n            if (!entry) {\r\n                return originalFsMethods.copyFileSync.apply(fs, arguments);\r\n            }\r\n            return originalFsMethods.writeFileSync(dest, nfs.readFileSync(filepath));\r\n        };\r\n    }\r\n    Object.assign(fs, nfs);\r\n    lazyRestoreFs = function () {\r\n        Object.keys(nfs).forEach(function (key) {\r\n            fs[key] = originalFsMethods[key];\r\n        });\r\n        lazyRestoreFs = function () { };\r\n    };\r\n    return true;\r\n}\r\nexports.shimFs = shimFs;\r\nfunction restoreFs() {\r\n    lazyRestoreFs();\r\n}\r\nexports.restoreFs = restoreFs;\r\n" +
        '\nshimFs(process.__nexe)' +
        ("\n" + (compiler.options.fs ? '' : 'restoreFs()'))
    //TODO support only restoring specific methods
    ));
    compiler.shims.push(util_1.wrap("\n    if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n      const cluster = require('cluster')\n      cluster._setupWorker()\n      delete process.env.NODE_UNIQUE_ID\n    }\n  "));
    compiler.shims.push(util_1.wrap("\n      if (!process.send) {\n        const path = require('path')\n        const entry = path.resolve(path.dirname(process.execPath)," + JSON.stringify(compiler.entrypoint) + ")\n        process.argv.splice(1,0, entry)\n      }\n    "));
    return next();
}
exports.default = default_1;
